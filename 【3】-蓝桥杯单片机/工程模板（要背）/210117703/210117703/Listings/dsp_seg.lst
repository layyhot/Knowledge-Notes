C51 COMPILER V9.59.0.0   DSP_SEG                                                           04/15/2024 16:46:50 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE DSP_SEG
OBJECT MODULE PLACED IN .\Objects\dsp_seg.obj
COMPILER INVOKED BY: E:\Keil5\C51\BIN\C51.EXE ..\Deriver\dsp_seg.c OPTIMIZE(8,SPEED) BROWSE INCDIR(..\Deriver;..\Sys;..\
                    -User) DEBUG OBJECTEXTEND PRINT(.\Listings\dsp_seg.lst) OBJECT(.\Objects\dsp_seg.obj)

line level    source

   1          #include "dsp_seg.h"
   2          
   3          
   4          //void Seg_Str_To_Buf(unsigned char* seg_str, unsigned char* seg_buf)
   5          //{
   6          //      unsigned char temp;
   7          //      unsigned char i, j;
   8          //      for(i = 0, j = 0; i < 10;i ++, j ++)
   9          //      {
  10          //              switch(seg_str[i])
  11          //              {
  12          //                      case '0': temp = 0xc0; break;
  13          //                      case '1': temp = 0xf9; break;                   
  14          //                      case '2': temp = 0xa4; break;
  15          //                      case '3': temp = 0xb0; break;                   
  16          //                      case '4': temp = 0x99; break;
  17          //                      case '5': temp = 0x92; break;                   
  18          //                      case '6': temp = 0x82; break;
  19          //                      case '7': temp = 0xf8; break;   
  20          //                      case '8': temp = 0x80; break;
  21          //                      case '9': temp = 0x90; break;                   
  22          //                      case 'A': temp = 0x88; break;
  23          //                      case 'B': temp = 0x83; break;                   
  24          //                      case 'C': temp = 0xc6; break;
  25          //                      case 'D': temp = 0xa1; break;                   
  26          //                      case 'E': temp = 0x86; break;
  27          //                      case 'F': temp = 0x8e; break;   //所有十六进制数据
  28          //                      
  29          //                      case 'H': temp = 0x89; break;                   
  30          //                      case 'L': temp = 0xc7; break;
  31          //                      case 'N': temp = 0xc8; break;                   
  32          //                      case 'P': temp = 0x8c; break;
  33          //                      case 'U': temp = 0xc1; break;   //回来女仆呦    
  34          
  35          //                      case '-': temp = 0xbf; break;                   
  36          //                      case ' ': temp = 0xff; break;   //两种特殊情况
  37          //                      
  38          //                      default: temp = 0xff; break;            //默认
  39          //              }
  40          //              
  41          //              if(seg_str[i + 1] == '.')  {temp &= 0x7f; i++;}
  42          //              seg_buf[j] = temp;
  43          //      }
  44          //}
  45          
  46          void Dsp_Seg(unsigned char* seg_buf, unsigned char pos)
  47          {
  48   1              P0 = (0x01 << pos);
  49   1              P2 = P2 & 0x1f | 0xc0;
  50   1              P2 &= 0x1f;
  51   1              
  52   1              P0 = 0;
  53   1              P2 = P2 & 0x1f | 0xe0;
  54   1              P2 &= 0x1f;
C51 COMPILER V9.59.0.0   DSP_SEG                                                           04/15/2024 16:46:50 PAGE 2   

  55   1              
  56   1              P0 = seg_buf[pos];
  57   1              P2 = P2 & 0x1f | 0xe0;
  58   1              P2 &= 0x1f;
  59   1      }
  60          
  61          void Seg_Str_To_Buf(unsigned char* seg_str, unsigned char* seg_buf)
  62          {
  63   1              unsigned char temp;
  64   1              unsigned char i, j;
  65   1              
  66   1              for(i = 0, j = 0; i <= 7; i ++, j ++)
  67   1              {
  68   2                      switch(seg_str[j])
  69   2                      {
  70   3                              case '0': temp = 0xc0; break;
  71   3                              case '1': temp = 0xf9; break;                   
  72   3                              case '2': temp = 0xa4; break;
  73   3                              case '3': temp = 0xb0; break;                   
  74   3                              case '4': temp = 0x99; break;
  75   3                              case '5': temp = 0x92; break;                   
  76   3                              case '6': temp = 0x82; break;
  77   3                              case '7': temp = 0xf8; break;   
  78   3                              case '8': temp = 0x80; break;
  79   3                              case '9': temp = 0x90; break;                   
  80   3                              case 'A': temp = 0x88; break;
  81   3                              case 'B': temp = 0x83; break;                   
  82   3                              case 'C': temp = 0xc6; break;
  83   3                              case 'D': temp = 0xa1; break;                   
  84   3                              case 'E': temp = 0x86; break;
  85   3                              case 'F': temp = 0x8e; break;   //所有十六进制数据
  86   3                              
  87   3                              case 'H': temp = 0x89; break;                   
  88   3                              case 'L': temp = 0xc7; break;
  89   3                              case 'N': temp = 0xc8; break;                   
  90   3                              case 'P': temp = 0x8c; break;
  91   3                              case 'U': temp = 0xc1; break;   //回来女仆呦    
  92   3      
  93   3                              case '-': temp = 0xbf; break;                   
  94   3                              case ' ': temp = 0xff; break;   //两种特殊情况
  95   3                              
  96   3                              default: temp = 0xff; break;            //默认
  97   3                      }
  98   2                      
  99   2                      if(seg_str[j + 1] == '.')       {temp &= 0x7f; j ++;}
 100   2                      
 101   2                      seg_buf[i] = temp;
 102   2              }
 103   1              
 104   1      }
 105                  


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    340    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----       9
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.

C51 COMPILER V9.59.0.0   DSP_SEG                                                           04/15/2024 16:46:50 PAGE 3   


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
